#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/wait.h>
#include <signal.h>


/* the port users will be connecting to */
#define MYPORT 3490

/* how many pending connections queue will hold */
#define BACKLOG 10

// max number of bytes we can get at once
#define MAXDATASIZE 300
int main(int argc, char *argv[ ]){
	/* later used for sock-conf */
	int yes = 1;
	
	/* later used */
	int new_fd;

	/* my address information */
	struct sockaddr_in my_addr;

	/* connectors address information */
	struct sockaddr_in their_addr;
	struct sigaction sa;

	/* recive */
	char buf[MAXDATASIZE];
	int recieve;
	/* create a new socket */
	/* AF_INET -> IPV4; SOCK_STREAM -> TCP */
	int sock;
	sock = socket(AF_INET, SOCK_STREAM, 0);

	/* checks for mistakes on socket creation */
	if(sock==-1){
		perror("CANT CREATE SOCKET");
		exit(1);
	} else {
		printf("SOCKET Creation successfull\n");
	}
	
	/* SOL_SOCKET -> request to socket layer, 
     * SO_REUSEADDR -> socketadress can reused */
	/* checks for mistakes on socket creation */
	if(setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) ==-1){
		perror("CANT CONF SOCKET");
		exit(1);
	} else {
		printf("SOCKET Configuration successfull\n");
	}

	/* host byte order */
	my_addr.sin_family = AF_INET;

	/* short, network byte order */
	my_addr.sin_port = htons(MYPORT);

	/* automatically fill with my IP */
	my_addr.sin_addr.s_addr = INADDR_ANY;

	printf("Server-Using %s and port %d...\n", inet_ntoa(my_addr.sin_addr), MYPORT);
	memset(&(my_addr.sin_zero), '\0', 8);

	/* tells the OS which port and address used */
	int binder;
	binder = bind(sock,(struct sockaddr *)&my_addr,sizeof(struct sockaddr));
	if(binder==-1){
		perror("CANT BIND SOCKET");
		exit(1);
	} else {
		printf("SOCKET Binded to OS\n");
	}

	/* config listener-queue */
	int listener;
	listener = listen(sock,BACKLOG);
	if(listener==-1){
		perror("CANT LISTEN SOCKET");
		exit(1);
	} else {
		printf("SOCKET Listen\n");
	}

	/* clean all the dead processes */
	//sa.sa_handler = sigchld_handler;
	//sigemptyset(&sa.sa_mask);
	//sa.sa_flags = SA_RESTART;

	/* start accept loop */
	while(1){
		int socklen = sizeof(struct sockaddr_in);
		if((new_fd=accept(sock, (struct sockaddr *)&their_addr, &socklen))==-1){
			perror("CANT ACCEPT CONNECTION");
			continue;
		} else {
			printf("SOCKET Accept\n");
		}

		char *message = "Hello Client, I am ready to work";
		send(new_fd,message,strlen(message),0);
		while(1){
			char buf[MAXDATASIZE];
			recieve = recv(new_fd,buf,MAXDATASIZE-1,0);
			buf[recieve]= '\0';
			printf("RECIVE: %s \n",buf);
			send(new_fd,"ACK",strlen("ACK"),0);		
		}
	}
	exit(0);
}
